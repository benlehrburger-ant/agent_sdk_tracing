<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Claude Chatbot</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      height: 100vh;
      display: flex;
      background: #f5f5f5;
      color: #1a1a1a;
    }

    /* Sidebar */
    .sidebar {
      width: 260px;
      background: #1a1a1a;
      color: #e5e5e5;
      display: flex;
      flex-direction: column;
      flex-shrink: 0;
    }

    .sidebar-header {
      padding: 16px;
      border-bottom: 1px solid #333;
    }

    .mode-toggle {
      display: flex;
      background: #333;
      border-radius: 6px;
      padding: 3px;
      margin-bottom: 10px;
    }

    .mode-toggle button {
      flex: 1;
      padding: 7px 0;
      background: none;
      color: #999;
      border: none;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 500;
      cursor: pointer;
      transition: background 0.15s, color 0.15s;
    }

    .mode-toggle button.active {
      background: #d97706;
      color: #fff;
    }

    .mode-toggle button:not(.active):hover {
      color: #ccc;
    }

    .new-chat-btn {
      width: 100%;
      padding: 10px;
      background: #d97706;
      color: #fff;
      border: none;
      border-radius: 6px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
    }

    .new-chat-btn:hover { background: #b45309; }

    .conversation-list {
      flex: 1;
      overflow-y: auto;
      padding: 8px;
    }

    .conversation-item {
      padding: 10px 12px;
      border-radius: 6px;
      cursor: pointer;
      font-size: 13px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 2px;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .conversation-item:hover { background: #2a2a2a; }
    .conversation-item.active { background: #333; }

    .conversation-item .title {
      overflow: hidden;
      text-overflow: ellipsis;
      flex: 1;
    }

    .delete-btn {
      background: none;
      border: none;
      color: #666;
      cursor: pointer;
      font-size: 16px;
      padding: 0 0 0 8px;
      flex-shrink: 0;
    }

    .delete-btn:hover { color: #ef4444; }

    /* Main area */
    .main {
      flex: 1;
      display: flex;
      flex-direction: column;
      min-width: 0;
    }

    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
    }

    .message {
      max-width: 720px;
      margin: 0 auto 16px;
      display: flex;
      gap: 12px;
    }

    .message .avatar {
      width: 32px;
      height: 32px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 14px;
      font-weight: 600;
      flex-shrink: 0;
    }

    .message.user .avatar { background: #d97706; color: #fff; }
    .message.assistant .avatar { background: #7c3aed; color: #fff; }

    .message .content {
      padding: 10px 16px;
      border-radius: 12px;
      line-height: 1.5;
      font-size: 14px;
      white-space: pre-wrap;
      word-break: break-word;
    }

    .message.user .content { background: #e5e5e5; }
    .message.assistant .content { background: #fff; border: 1px solid #e0e0e0; }

    .empty-state {
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100%;
      color: #999;
      font-size: 18px;
    }

    /* Input */
    .input-area {
      padding: 16px 24px 24px;
      background: #f5f5f5;
    }

    .input-wrapper {
      max-width: 720px;
      margin: 0 auto;
      display: flex;
      gap: 8px;
    }

    .input-wrapper textarea {
      flex: 1;
      padding: 12px 16px;
      border: 1px solid #ccc;
      border-radius: 12px;
      font-size: 14px;
      font-family: inherit;
      resize: none;
      outline: none;
      min-height: 46px;
      max-height: 150px;
    }

    .input-wrapper textarea:focus { border-color: #d97706; }

    .send-btn {
      padding: 0 20px;
      background: #d97706;
      color: #fff;
      border: none;
      border-radius: 12px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      align-self: flex-end;
      height: 46px;
    }

    .send-btn:hover { background: #b45309; }
    .send-btn:disabled { background: #ccc; cursor: not-allowed; }

    /* Drag-and-drop overlay */
    .drop-overlay {
      display: none;
      position: absolute;
      inset: 0;
      background: rgba(217, 119, 6, 0.08);
      border: 2px dashed #d97706;
      border-radius: 12px;
      z-index: 10;
      align-items: center;
      justify-content: center;
      font-size: 16px;
      font-weight: 500;
      color: #d97706;
      pointer-events: none;
    }

    .main.dragging .drop-overlay { display: flex; }

    /* Attached files */
    .attached-files {
      max-width: 720px;
      margin: 0 auto 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .file-chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 10px;
      background: #e5e5e5;
      border-radius: 6px;
      font-size: 12px;
      color: #333;
    }

    .file-chip .remove {
      background: none;
      border: none;
      cursor: pointer;
      color: #999;
      font-size: 14px;
      padding: 0;
      line-height: 1;
    }

    .file-chip .remove:hover { color: #ef4444; }

    /* Loading dots */
    .typing-indicator {
      display: inline-flex;
      gap: 4px;
      padding: 4px 0;
    }

    .typing-indicator span {
      width: 6px;
      height: 6px;
      background: #999;
      border-radius: 50%;
      animation: bounce 1.2s infinite ease-in-out;
    }

    .typing-indicator span:nth-child(2) { animation-delay: 0.2s; }
    .typing-indicator span:nth-child(3) { animation-delay: 0.4s; }

    @keyframes bounce {
      0%, 60%, 100% { transform: translateY(0); opacity: 0.4; }
      30% { transform: translateY(-4px); opacity: 1; }
    }

    /* File attachment in messages */
    .message .files {
      margin-top: 6px;
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
    }

    .message .file-tag {
      display: inline-block;
      padding: 2px 8px;
      background: rgba(0,0,0,0.06);
      border-radius: 4px;
      font-size: 11px;
      color: #666;
    }
  </style>
</head>
<body>
  <div class="sidebar">
    <div class="sidebar-header">
      <div class="mode-toggle">
        <button id="modeAgentSDK" class="active" onclick="setMode('agent-sdk')">Agent SDK</button>
        <button id="modeMessagesAPI" onclick="setMode('messages-api')">Messages API</button>
      </div>
      <button class="new-chat-btn" onclick="newConversation()">+ New Chat</button>
    </div>
    <div class="conversation-list" id="conversationList"></div>
  </div>

  <div class="main" id="mainArea">
    <div class="drop-overlay">Drop files here</div>
    <div class="messages" id="messages">
      <div class="empty-state">Send a message to start chatting</div>
    </div>
    <div class="input-area">
      <div class="attached-files" id="attachedFiles"></div>
      <div class="input-wrapper">
        <textarea id="input" placeholder="Type a message or drop files..." rows="1"
          onkeydown="if(event.key==='Enter'&&!event.shiftKey){event.preventDefault();sendMessage();}"></textarea>
        <button class="send-btn" id="sendBtn" onclick="sendMessage()">Send</button>
      </div>
    </div>
  </div>

  <script>
    const STORAGE_KEYS = {
      "agent-sdk": "claude_chatbot_conversations",
      "messages-api": "claude_chatbot_conversations_messages_api",
    };

    let currentMode = "agent-sdk";
    let conversations = JSON.parse(localStorage.getItem(STORAGE_KEYS[currentMode]) || "{}");
    let activeId = null;
    let isStreaming = false;
    let pendingFiles = []; // { name, content }

    function setMode(mode) {
      if (mode === currentMode) return;
      // Save current state
      save();
      // Switch mode
      currentMode = mode;
      conversations = JSON.parse(localStorage.getItem(STORAGE_KEYS[currentMode]) || "{}");
      // Update toggle buttons
      document.getElementById("modeAgentSDK").classList.toggle("active", mode === "agent-sdk");
      document.getElementById("modeMessagesAPI").classList.toggle("active", mode === "messages-api");
      // Reset active conversation
      const ids = Object.keys(conversations);
      activeId = ids.length > 0
        ? ids.sort((a, b) => conversations[b].updatedAt - conversations[a].updatedAt)[0]
        : null;
      renderSidebar();
      renderMessages();
    }

    // Auto-grow textarea
    const input = document.getElementById("input");
    input.addEventListener("input", () => {
      input.style.height = "auto";
      input.style.height = Math.min(input.scrollHeight, 150) + "px";
    });

    // --- Drag and drop ---
    const mainArea = document.getElementById("mainArea");
    let dragCounter = 0;

    mainArea.addEventListener("dragenter", (e) => {
      e.preventDefault();
      dragCounter++;
      mainArea.classList.add("dragging");
    });

    mainArea.addEventListener("dragleave", (e) => {
      e.preventDefault();
      dragCounter--;
      if (dragCounter === 0) mainArea.classList.remove("dragging");
    });

    mainArea.addEventListener("dragover", (e) => e.preventDefault());

    mainArea.addEventListener("drop", (e) => {
      e.preventDefault();
      dragCounter = 0;
      mainArea.classList.remove("dragging");
      handleDroppedFiles(e.dataTransfer.files);
    });

    // Also allow paste
    input.addEventListener("paste", (e) => {
      const files = e.clipboardData?.files;
      if (files && files.length > 0) {
        e.preventDefault();
        handleDroppedFiles(files);
      }
    });

    const BINARY_EXTENSIONS = new Set([
      "png", "jpg", "jpeg", "gif", "webp", "bmp", "ico", "svg",
      "pdf",
      "zip", "gz", "tar", "rar", "7z",
      "mp3", "wav", "ogg", "mp4", "mov", "avi", "mkv",
      "doc", "docx", "xls", "xlsx", "ppt", "pptx",
      "woff", "woff2", "ttf", "otf", "eot",
    ]);

    function isBinaryFile(name) {
      const ext = name.split(".").pop().toLowerCase();
      return BINARY_EXTENSIONS.has(ext);
    }

    function handleDroppedFiles(fileList) {
      for (const file of fileList) {
        const reader = new FileReader();
        const binary = isBinaryFile(file.name);
        reader.onload = () => {
          const entry = { name: file.name, mediaType: file.type };
          if (binary) {
            // Strip data URL prefix to get raw base64
            entry.content = reader.result.split(",")[1];
            entry.encoding = "base64";
          } else {
            entry.content = reader.result;
            entry.encoding = "text";
          }
          pendingFiles.push(entry);
          renderAttachedFiles();
        };
        if (binary) {
          reader.readAsDataURL(file);
        } else {
          reader.readAsText(file);
        }
      }
    }

    function renderAttachedFiles() {
      const container = document.getElementById("attachedFiles");
      container.innerHTML = pendingFiles
        .map(
          (f, i) =>
            `<div class="file-chip">
              <span>${escapeHtml(f.name)}</span>
              <button class="remove" onclick="removeFile(${i})">&times;</button>
            </div>`
        )
        .join("");
    }

    function removeFile(index) {
      pendingFiles.splice(index, 1);
      renderAttachedFiles();
    }

    function save() {
      localStorage.setItem(STORAGE_KEYS[currentMode], JSON.stringify(conversations));
    }

    function generateId() {
      return Date.now().toString(36) + Math.random().toString(36).slice(2, 7);
    }

    function renderSidebar() {
      const list = document.getElementById("conversationList");
      const sorted = Object.entries(conversations).sort(
        (a, b) => b[1].updatedAt - a[1].updatedAt
      );

      list.innerHTML = sorted
        .map(
          ([id, conv]) => `
        <div class="conversation-item ${id === activeId ? "active" : ""}" onclick="loadConversation('${id}')">
          <span class="title">${escapeHtml(conv.title)}</span>
          <button class="delete-btn" onclick="event.stopPropagation();deleteConversation('${id}')">&times;</button>
        </div>`
        )
        .join("");
    }

    function renderMessages() {
      const container = document.getElementById("messages");
      const conv = conversations[activeId];

      if (!conv || conv.messages.length === 0) {
        container.innerHTML =
          '<div class="empty-state">Send a message to start chatting</div>';
        return;
      }

      container.innerHTML = conv.messages
        .map(
          (m, i) => {
            const isLastEmpty = isStreaming && i === conv.messages.length - 1 && m.role === "assistant" && !m.text;
            const body = isLastEmpty
              ? '<div class="typing-indicator"><span></span><span></span><span></span></div>'
              : escapeHtml(m.text);
            const files = m.files && m.files.length
              ? `<div class="files">${m.files.map((f) => `<span class="file-tag">${escapeHtml(f)}</span>`).join("")}</div>`
              : "";
            return `
        <div class="message ${m.role}">
          <div class="avatar">${m.role === "user" ? "Y" : "C"}</div>
          <div class="content">${body}${files}</div>
        </div>`;
          }
        )
        .join("");

      container.scrollTop = container.scrollHeight;
    }

    function escapeHtml(str) {
      const div = document.createElement("div");
      div.textContent = str;
      return div.innerHTML;
    }

    function newConversation() {
      const id = generateId();
      conversations[id] = {
        title: "New Chat",
        messages: [],
        createdAt: Date.now(),
        updatedAt: Date.now(),
      };
      activeId = id;
      save();
      renderSidebar();
      renderMessages();
      input.focus();
    }

    function loadConversation(id) {
      activeId = id;
      renderSidebar();
      renderMessages();
      input.focus();
    }

    function deleteConversation(id) {
      delete conversations[id];
      if (activeId === id) {
        const remaining = Object.keys(conversations);
        activeId = remaining.length > 0 ? remaining[0] : null;
      }
      save();
      renderSidebar();
      renderMessages();
    }

    async function sendMessage() {
      const text = input.value.trim();
      const files = [...pendingFiles];
      if ((!text && files.length === 0) || isStreaming) return;

      // Create conversation if none active
      if (!activeId) newConversation();

      const conv = conversations[activeId];
      const userMsg = { role: "user", text: text || "(attached files)" };
      if (files.length > 0) {
        userMsg.files = files.map((f) => f.name);
      }
      conv.messages.push(userMsg);

      // Set title from first message
      if (conv.messages.length === 1) {
        const titleSource = text || files.map((f) => f.name).join(", ");
        conv.title =
          titleSource.slice(0, 40) + (titleSource.length > 40 ? "..." : "");
      }

      conv.updatedAt = Date.now();
      save();
      renderMessages();
      renderSidebar();

      input.value = "";
      input.style.height = "auto";
      pendingFiles = [];
      renderAttachedFiles();
      isStreaming = true;
      document.getElementById("sendBtn").disabled = true;

      // Add empty assistant message to fill in
      conv.messages.push({ role: "assistant", text: "" });
      renderMessages();

      try {
        const body = { message: text, conversationId: activeId, mode: currentMode };
        if (files.length > 0) {
          body.files = files.map((f) => ({
            name: f.name,
            content: f.content,
            encoding: f.encoding,
            mediaType: f.mediaType,
          }));
        }

        const res = await fetch("/api/chat", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(body),
        });

        const reader = res.body.getReader();
        const decoder = new TextDecoder();
        let buffer = "";

        while (true) {
          const { done, value } = await reader.read();
          if (done) break;

          buffer += decoder.decode(value, { stream: true });
          const lines = buffer.split("\n");
          buffer = lines.pop(); // keep incomplete line

          for (const line of lines) {
            if (!line.startsWith("data: ")) continue;
            const data = line.slice(6);
            if (data === "[DONE]") break;

            try {
              const parsed = JSON.parse(data);
              if (parsed.text) {
                const last = conv.messages[conv.messages.length - 1];
                last.text += parsed.text;
                renderMessages();
              }
              if (parsed.error) {
                const last = conv.messages[conv.messages.length - 1];
                last.text = "Error: " + parsed.error;
                renderMessages();
              }
            } catch {}
          }
        }
      } catch (err) {
        const last = conv.messages[conv.messages.length - 1];
        last.text = "Error: Failed to connect to server.";
        renderMessages();
      }

      conv.updatedAt = Date.now();
      save();
      isStreaming = false;
      document.getElementById("sendBtn").disabled = false;
      input.focus();
    }

    // Boot
    const ids = Object.keys(conversations);
    if (ids.length > 0) {
      activeId = ids.sort(
        (a, b) => conversations[b].updatedAt - conversations[a].updatedAt
      )[0];
    }
    renderSidebar();
    renderMessages();
  </script>
</body>
</html>
